<?xml version="1.0" encoding="UTF-8"?>
<solver>
    <!-- Use FULL_ASSERT to turn on all debug warnings -->
    <environmentMode>REPRODUCIBLE</environmentMode>

    <!-- Use a RNG from commons-math to make results repeatable across JVMs -->
    <randomType>MERSENNE_TWISTER</randomType>

    <!-- Force the same initial random seed -->
    <randomSeed>0</randomSeed>

    <!-- Domain model configuration -->
    <solutionClass>com.suse.matcher.solver.Assignment</solutionClass>
    <entityClass>com.suse.matcher.solver.Match</entityClass>

    <!-- Score configuration -->
    <scoreDirectorFactory>
        <scoreDefinitionType>HARD_SOFT</scoreDefinitionType>
        <scoreDrl>com/suse/matcher/rules/optaplanner/Scores.drl</scoreDrl>
        <initializingScoreTrend>ONLY_DOWN/ONLY_UP</initializingScoreTrend>
    </scoreDirectorFactory>

    <!-- Optimization algorithm configuration -->

    <!-- Construct a first solution by iterating through possible matches and switching Match.confirmed from null to true
         or false, whatever has higher score. By construction the hard score cannot become negative and the soft score
         comes out typically better than 0
    -->
    <constructionHeuristic>
        <constructionHeuristicType>FIRST_FIT</constructionHeuristicType>
    </constructionHeuristic>

    <!-- Iteratively improve the solution -->
    <localSearch>
        <!-- Iteratively propose new solutions by changing some of the current solution's Match.confirmed boolean values.
             A change from a certain solution to a new solution is called a move, and moves are performed repeatedly in
             iterations called steps.
             We allow moves to change from 1 to 4 Match.confirmed values per step.
        -->
        <unionMoveSelector>
            <changeMoveSelector/>
            <cartesianProductMoveSelector>
                <changeMoveSelector/>
                <changeMoveSelector/>
            </cartesianProductMoveSelector>
            <cartesianProductMoveSelector>
                <changeMoveSelector/>
                <changeMoveSelector/>
                <changeMoveSelector/>
            </cartesianProductMoveSelector>
            <cartesianProductMoveSelector>
                <changeMoveSelector/>
                <changeMoveSelector/>
                <changeMoveSelector/>
                <changeMoveSelector/>
            </cartesianProductMoveSelector>
            <!-- Generate at most 20000 moves per step -->
            <selectedCountLimit>20000</selectedCountLimit>
        </unionMoveSelector>

        <!-- Don't accept moves:
              - that do not actually change the solution (eg. true -> true), implicit
              - that make the hard score negative, implicit
              - that were already attempted in the last 50 steps (colloquially they are "taboo").
                This prevents us to run in circles, repeating the same moves over and over
        -->
        <acceptor>
            <moveTabuSize>50</moveTabuSize>
        </acceptor>

        <!-- Generate at most 10000 acceptable moves per step -->
        <forager>
            <acceptedCountLimit>10000</acceptedCountLimit>
        </forager>

        <!-- At the end of each step, pick the accepted move with best score that has been found.
             That score might or might not be an improvement to the overall best score.
             In any case, the new solution is used as the basis for the next step -->
 
        <termination>
            <!-- Terminate after 500 steps with no score improvement -->
            <unimprovedStepCountLimit>500</unimprovedStepCountLimit>

            <!-- Terminate after 10000 steps in any case -->
            <stepCountLimit>10000</stepCountLimit>
        </termination>
    </localSearch>
</solver>
