package com.suse.matcher.rules.drools;

import com.suse.matcher.facts.PinnedMatch;
import com.suse.matcher.facts.Subscription;
import com.suse.matcher.facts.SubscriptionProduct;
import com.suse.matcher.facts.System;

// Agenda group for converting old style hard bundles (consisting of more subscriptions)
// into a single-subscription hard bundle

// For 2 sets of products from 2 subscriptions in a hard bundle, we assume that if they don't
// have the product class, we set a fake product class per subscription.
rule "fakeProductClasses"
    agenda-group "HardBundleConversion"
    when
        $sub : Subscription(ignored == false, hardBundleId != null, $subscriptionId : id)
        SubscriptionProduct(subscriptionId == $subscriptionId, $prodId : productId)
        $prod : Product(productClass == null, id == $prodId)
    then
        modify($prod) {
            setProductClass("generated-product-class-" + $subscriptionId.toString());
        }
end

rule "mergeProducts"
    agenda-group "HardBundleConversion"
    when
        Subscription(ignored == false, hardBundleId != null, $sub1HardBundleId : hardBundleId, $sub1Id : id)
        $subToRetract : Subscription(id > $sub1Id, hardBundleId == $sub1HardBundleId)
        $subProd : SubscriptionProduct(subscriptionId == $subToRetract.id);
    then
        // we cannot use modify() because subscriptionId is in hashCode, retract and insert instead
        insert(new SubscriptionProduct($sub1Id, $subProd.productId));
        retract($subProd);
end

rule "mergePinnedMatches"
    agenda-group "HardBundleConversion"
    when
        Subscription(ignored == false, hardBundleId != null, $sub1HardBundleId : hardBundleId, $sub1Id : id)
        $subToRetract : Subscription(id > $sub1Id, hardBundleId == $sub1HardBundleId)
        $pinnedMatch : PinnedMatch(subscriptionId == $subToRetract.id)
    then
        // we cannot use modify() because of attributes in hashCode, retract and insert instead
        insert(new PinnedMatch($pinnedMatch.systemId, $sub1Id));
        retract($pinnedMatch);
end

rule "removeRedundantSubscriptions"
    agenda-group "HardBundleConversion"
    when
        $subToKeep: Subscription(ignored == false, hardBundleId != null, $sub1HardBundleId : hardBundleId, $id : id)
        $subToRetract : Subscription(id > $id, hardBundleId == $sub1HardBundleId)
    then
        modify($subToKeep) {
            setName($subToKeep.name + " + " + $subToRetract.name);
        }
        retract($subToRetract);
end

