<?xml version="1.0" encoding="UTF-8"?>
<solver>
    <!-- Use FULL_ASSERT to turn on all debug warnings -->
    <environmentMode>REPRODUCIBLE</environmentMode>

    <!-- Use a RNG from commons-math to make results repeatable across JVMs -->
    <randomType>MERSENNE_TWISTER</randomType>

    <!-- Force the same initial random seed -->
    <randomSeed>0</randomSeed>

    <!-- Domain model configuration -->
    <solutionClass>com.suse.matcher.solver.Assignment</solutionClass>
    <entityClass>com.suse.matcher.solver.Match</entityClass>

    <!-- Score configuration -->
    <scoreDirectorFactory>
        <scoreDefinitionType>HARD_SOFT</scoreDefinitionType>
        <scoreDrl>com/suse/matcher/rules/optaplanner/Scores.drl</scoreDrl>
        <initializingScoreTrend>ONLY_DOWN/ONLY_UP</initializingScoreTrend>
    </scoreDirectorFactory>

    <!-- Optimization algorithm configuration -->

    <!-- Construct a first solution by iterating through possible matches and switching Match.confirmed from null to true
         or false, whatever has higher score. By construction the hard score cannot become negative and the soft score
         comes out typically better than 0
    -->
    <constructionHeuristic>
        <constructionHeuristicType>FIRST_FIT</constructionHeuristicType>
    </constructionHeuristic>

    <!-- Iteratively improve the solution -->
    <localSearch>
        <!-- Propose new solutions by changing the current solutions's Match.confirmed boolean values (in random Match
        instances). One such change is called a change move.
        Additionally, propose new solutions by swapping the confirmed values of two Match instances. One such change
        is called a swap move.
        -->
        <unionMoveSelector>
            <changeMoveSelector/>
            <cartesianProductMoveSelector>
                <changeMoveSelector/>
                <changeMoveSelector/>
            </cartesianProductMoveSelector>
            <cartesianProductMoveSelector>
                <changeMoveSelector/>
                <changeMoveSelector/>
                <changeMoveSelector/>
            </cartesianProductMoveSelector>
            <cartesianProductMoveSelector>
                <changeMoveSelector/>
                <changeMoveSelector/>
                <changeMoveSelector/>
                <changeMoveSelector/>
            </cartesianProductMoveSelector>
            <!-- Generate at most 2000 moves per step -->
            <selectedCountLimit>2000</selectedCountLimit>
        </unionMoveSelector>

        <!-- Don't accept moves:
              - that do not actually change the solution (eg. true -> true)
              - that make the hard score negative
              - that were already attempted in the last 50 steps (colloquially they are "taboo")
        -->
        <acceptor>
            <moveTabuSize>50</moveTabuSize>
        </acceptor>

        <!-- In any case, don't generate more than 1000 acceptable moves -->
        <forager>
            <acceptedCountLimit>1000</acceptedCountLimit>
        </forager>

        <!-- Implicitly pick the accepted move with best score that has been found. It might or might not improve
             the current overall best score. When the move is picked a "step" is finished and move evaluation restarts
             from the new solution -->
 
        <termination>
            <!-- Terminate after 100 steps with no score improvement -->
            <unimprovedStepCountLimit>100</unimprovedStepCountLimit>
        </termination>
    </localSearch>
</solver>
