package com.suse.matcher.rules.drools;

import com.suse.matcher.Drools;
import com.suse.matcher.facts.HostedProduct;
import com.suse.matcher.facts.HostGuest;
import com.suse.matcher.facts.InstalledProduct;
import com.suse.matcher.facts.PenaltyGroup;
import com.suse.matcher.facts.Subscription;
import com.suse.matcher.facts.SubscriptionProduct;
import com.suse.matcher.facts.System;
import com.suse.matcher.facts.VirtualizationGroupMember;

rule "generateHostedProduct"
    agenda-group "InputAugmenting"
    when
        System($systemId : id, physical == false)
        InstalledProduct(systemId == $systemId, $productId : productId)
        HostGuest($hostId : hostId, guestId == $systemId)
    then
        insert(new HostedProduct($hostId, $productId));
end

rule "generatePenaltyGroupsFromVirtualizationGroups"
    agenda-group "InputAugmenting"
    when
        VirtualizationGroupMember($virtualizationGroupId : virtualizationGroupId, $guestId : guestId)
    then
        insert(new PenaltyGroup($virtualizationGroupId, $guestId));
end

rule "generatePenaltyGroups"
    agenda-group "InputAugmenting"
    when
        HostGuest($hostId : hostId, $guestId : guestId)
        not VirtualizationGroupMember(guestId == $guestId)
    then
        int penaltyGroupId = Drools.generateId("host_guest", $hostId);
        insert(new PenaltyGroup(penaltyGroupId, $guestId));
end

// aggregate 2 equal (same properties, same product set) OEM subscriptions into a single one
rule "aggregateEqualStackableSubscriptions"
    agenda-group "InputAugmenting"
    when
        $s1: Subscription(ignored == false, stackable == true, id < 0, aggregationSubscriptionId == null || aggregationSubscriptionId == id)

        // make sure that the $s1 is the one that has lowest id
        not Subscription(
            ignored == false,
            stackable == true,
            id < 0, // OEM subscription
            id < $s1.id,
            partNumber == $s1.partNumber,
            name == $s1.name,
            policy == $s1.policy,
            cpus == $s1.cpus,
            sccUsername == $s1.sccUsername,
            quantity == 1)

        $s2: Subscription(
            ignored == false,
            stackable == true,
            id < 0, // OEM subscription
            id > $s1.id,
            id != aggregationSubscriptionId, // rule out subs that already aggregate other subscription
            partNumber == $s1.partNumber,
            name == $s1.name,
            policy == $s1.policy,
            cpus == $s1.cpus,
            sccUsername == $s1.sccUsername,
            quantity == 1)

        accumulate(
            $product1: SubscriptionProduct(subscriptionId == $s1.id);
            $productIds1: collectSet($product1.productId)
        )

        accumulate(
            $product2: SubscriptionProduct(subscriptionId == $s2.id);
            $productIds2: collectSet($product2.productId);
            $productIds2 == $productIds1
        )

        // we're gonna remove the subscription -> let's also adjust its pinned matches
        accumulate(
            $pinnedMatch: PinnedMatch(subscriptionId == $s2.id);
            $pinnedMatches: collectSet($pinnedMatch)
        )
    then
        modify($s1) {
            quantity += $s2.quantity,
            aggregationSubscriptionId = $s1.id,
            startDate = $s1.startDate.after($s2.startDate) ? $s1.startDate : $s2.startDate,
            endDate = $s1.endDate.before($s2.endDate) ? $s1.endDate : $s2.endDate
        }
        modify($s2) {
            aggregationSubscriptionId = $s1.id
        }

        TreeMap<String, String> msgData = new TreeMap<>();
        msgData.put("old_subscription_id", $s2.id.toString());
        msgData.put("new_subscription_id", $s1.id.toString());
        insert(new Message(Message.Level.INFO, "merge_subscriptions", msgData));

        for (Object pm : $pinnedMatches) {
            Long systemId = ((PinnedMatch) pm).systemId;

            insert(new PinnedMatch(systemId, $s1.id));
            retract(pm);

            TreeMap<String, String> data = new TreeMap<>();
            data.put("old_subscription_id", $s2.id.toString());
            data.put("new_subscription_id", $s1.id.toString());
            data.put("system_id", systemId.toString());
            insert(new Message(Message.Level.INFO, "adjust_pinned_match", data));
        }

        retract($s2);
end

rule "removeRedundantSubscriptionProducts"
    agenda-group "InputAugmenting"
    when
        $sp: SubscriptionProduct()
        not Subscription(id == $sp.subscriptionId)
    then
        retract($sp)
end

rule "adjustAggregatedSubscriptionName"
    agenda-group "InputAugmenting"
    no-loop
    when
        $s: Subscription(aggregationSubscriptionId == id, !name.startsWith("Aggregated:"))
    then
        modify($s) {
            name = "Aggregated: " + $s.name
        }
end
