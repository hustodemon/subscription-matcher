package com.suse.matcher.rules.drools;

import java.util.List;

import com.suse.matcher.facts.HostGuest;
import com.suse.matcher.facts.IncompatibleGroups;
import com.suse.matcher.facts.PartialMatch;
import com.suse.matcher.facts.Product;
import com.suse.matcher.facts.Subscription;
import com.suse.matcher.facts.Subscription.Policy;
import com.suse.matcher.facts.SubscriptionProduct;
import com.suse.matcher.facts.System;
import com.suse.matcher.facts.SystemProduct;

rule "matchPhysicalOnlySubscription"
    when
        $system : System($systemId : id, physical == true)
        SystemProduct($productId : productId, systemId == $systemId)
        SubscriptionProduct($subscriptionId : subscriptionId, productId == $productId)
        $subscription : Subscription(
            id == $subscriptionId,
            policy == Policy.PHYSICAL_ONLY,
            cpus >= $system.cpus,
            ignored == false
        )
    then
        int groupId = PartialMatch.generateGroupId($system.id, $productId, $subscription.id);
        insertLogical(new PartialMatch($system.id, $productId, $subscription.id, 100, groupId));
end

rule "matchInstanceSubscription"
    when
        $system : System($systemId : id)
        SystemProduct($productId : productId, systemId == $systemId)
        SubscriptionProduct($subscriptionId : subscriptionId, productId == $productId)
        $subscription : Subscription(
            id == $subscriptionId,
            policy == Policy.INSTANCE,
            (cpus == null || cpus >= $system.cpus),
            ignored == false
        )
    then
        int groupId = PartialMatch.generateGroupId($system.id, $productId, $subscription.id);
        insertLogical(new PartialMatch($system.id, $productId, $subscription.id, 100, groupId));
end

rule "matchUnlimitedVirtualizationSubscription"
    when
        $system : System($systemId : id, physical == true, cpus != null)
        (
            SystemProduct($productId : productId, systemId == $systemId) or
            (
                HostGuest(hostId == $systemId, $guestId : guestId) and
                SystemProduct($productId : productId, systemId == $guestId)
            )
        )
        SubscriptionProduct($subscriptionId : subscriptionId, productId == $productId)
        $subscription : Subscription(
            id == $subscriptionId,
            policy == Policy.UNLIMITED_VIRTUALIZATION,
            (cpus >= $system.cpus || stackable == true),
            ignored == false
        )
    then
        Integer consumedQuantity = ($system.cpus + $subscription.cpus - 1) / $subscription.cpus;
        int groupId = PartialMatch.generateGroupId($system.id, $productId, $subscription.id);
        insertLogical(new PartialMatch($system.id, $productId, $subscription.id, consumedQuantity * 100, groupId));
end

rule "matchFreeVirtualizationSubscription"
    when
      PartialMatch($hostId : systemId, $productId : productId, $subscriptionId : subscriptionId, $groupId : groupId)
      Subscription(id == $subscriptionId, policy == Policy.UNLIMITED_VIRTUALIZATION, ignored == false)
      HostGuest(hostId == $hostId, $guestId : guestId)
    then
      insertLogical(new PartialMatch($guestId, $productId, $subscriptionId, 0, $groupId));
end

rule "matchInheritedVirtualization"
    no-loop
    when
        // for each base product
        Product($productId : id, base == true)

        // for each installed add-on product with an IV subscription
        Subscription($ivSubsId : id, policy == Policy.INHERITED_VIRTUALIZATION, ignored == false)
        SubscriptionProduct(subscriptionId == $ivSubsId, $ivProdId : productId)
        (
            SystemProduct(productId == $ivProdId, $systemId : systemId) or
            (
                SystemProduct($guestId : systemId, productId == $ivProdId) and
                HostGuest($systemId : hostId, guestId == $guestId)
            )
        )

        // for each match
        PartialMatch($subscriptionId : subscriptionId, $cents : cents, $groupId : groupId, productId == $productId, systemId == $systemId)
    then
        int groupId = PartialMatch.generateGroupIdFromBaseGroupId($groupId, $subscriptionId);
        insertLogical(new PartialMatch($systemId, $productId, $subscriptionId, $cents, groupId));
        insertLogical(new PartialMatch($systemId, $ivProdId, $ivSubsId, $cents, groupId));
end

rule "match12Subscription"
    when
        // we want to explicitly bind 'physical' here as we want the rule to be reactivated on change of this attribute:
        $system : System($systemId : id, $physical : physical, cpus != null)
        SystemProduct($productId : productId, systemId == $systemId)
        SubscriptionProduct($subscriptionId : subscriptionId, productId == $productId)
        $subscription : Subscription(
            id == $subscriptionId,
            policy == Policy.ONE_TWO,
            ignored == false
        )
        not (HostGuest(hostId == $systemId))
    then
        int groupId = PartialMatch.generateGroupId($systemId, $productId, $subscriptionId);
        if ($physical) {
            insertLogical(new PartialMatch($system.id, $productId, $subscription.id,
                ($system.cpus + $subscription.cpus - 1) / $subscription.cpus * 100,
                groupId));
        }
        else {
            insertLogical(new PartialMatch($system.id, $productId, $subscription.id, 50, groupId));
        }
end

rule "findIncompatibleGroups"
    when
        PartialMatch($groupId1 : groupId, $systemId : systemId, $productId : productId, $subscriptionId : subscriptionId)
        PartialMatch($groupId2 : groupId, groupId > $groupId1, systemId == $systemId, productId == $productId, subscriptionId != $subscriptionId)
    then
        insertLogical(new IncompatibleGroups($groupId1, $groupId2));
end
