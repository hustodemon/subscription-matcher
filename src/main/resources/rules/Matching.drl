package com.suse.matcher.rules;

import com.suse.matcher.facts.HostGuest;
import com.suse.matcher.facts.Match;
import com.suse.matcher.facts.Match.Kind;
import com.suse.matcher.facts.Subscription;
import com.suse.matcher.facts.SubscriptionProduct;
import com.suse.matcher.facts.System;
import com.suse.matcher.facts.SystemProduct;

rule "match valid user-specified matches"
    agenda-group "Matching"
    salience 2
    when
        Match($systemId : systemId, $productId : productId, $subscriptionId : subscriptionId, kind == Kind.USER_PINNED)
        Match($quantity: quantity, systemId == $systemId, productId == $productId, subscriptionId == $subscriptionId, kind == Kind.POSSIBLE)
    then
        insert(new Match($systemId, $productId, $subscriptionId, $quantity, Kind.CONFIRMED));
end

rule "match non-stackable matches"
    agenda-group "Matching"
    salience $subscription.computeFitnessTo($system) // result in interval [0, 1]
    when
        // we have a system
        $system : System($systemId : id)
        // we have a non-stackable subscription with available slots
        $subscription : Subscription(
            $subscriptionId : id,
            $quantity : quantity,
            quantity > 0,
            stackable == false
        )

        // we have a possible match with a product
        Match($usedQuantity : quantity, systemId == $systemId, $productId : productId, subscriptionId == $subscriptionId, kind == Kind.POSSIBLE)

        // and that product is provided by the subscription
        SubscriptionProduct(subscriptionId == $subscriptionId, productId == $productId)

        // unless other subscriptions have already been assigned
        not (Match(systemId == $systemId, kind == Kind.CONFIRMED))
    then
        insert(new Match($systemId, $productId, $subscriptionId, $usedQuantity, Kind.CONFIRMED));
        modify($subscription) {
            quantity = $quantity - $usedQuantity
        }
end

rule "match stackable matches"
    // NOTE: the only stackable subscriptions are TWO_TWO and UNLIMITED_VIRTUAL after 2015
    agenda-group "Matching"
    salience $subscription.computeFitnessTo($system) // result in interval [0, 1]
    when
        // we have a physical system
        $system : System($systemId : id, physical)
        // we have a stackable subscription with enough slots
        $subscription : Subscription(
            $subscriptionId : id,
            $quantity : quantity,
            quantity * cpus >= $system.cpus,
            stackable == true
        )

        // we have a possible match with a product
        Match($usedQuantity : quantity, systemId == $systemId, $productId : productId, subscriptionId == $subscriptionId, kind == Kind.POSSIBLE)

        // and that product is provided by the subscription
        SubscriptionProduct(subscriptionId == $subscriptionId, productId == $productId)

        // unless other subscriptions have already been assigned
        not (Match(systemId == $systemId, kind == Kind.CONFIRMED))
    then
        insert(new Match($systemId, $productId, $subscriptionId, $usedQuantity, Kind.CONFIRMED));
        modify($subscription) {
            quantity = $quantity - $usedQuantity
        }
end

rule "match VM-only matches"
    // the subscriptions that can match VMs directly are TWO_TWO after 2015
    agenda-group "Matching"
    salience $subscription.computeFitnessTo($system) // result in interval [0, 1]
    when
        // we have a virtual system
        $system : System($systemId : id, physical == false)
        // we have a TWO_TWO subscription with enough slots
        $subscription : Subscription(
            $subscriptionId : id,
            $quantity : quantity,
            quantity >= 0.5
        )

        // we have a possible match with a product
        Match($usedQuantity : quantity, systemId == $systemId, $productId : productId, subscriptionId == $subscriptionId, kind == Kind.POSSIBLE)

        // and that product is provided by the subscription
        SubscriptionProduct(subscriptionId == $subscriptionId, productId == $productId)

        // unless other subscriptions have already been assigned
        not (Match(systemId == $systemId, kind == Kind.CONFIRMED))
    then
        insert(new Match($systemId, $productId, $subscriptionId, 0.5, Kind.CONFIRMED));
        modify($subscription) {
            quantity = $quantity - 0.5
        }
end

rule "match virtual machines included in hosts's subscriptions"
    agenda-group "Matching"
    when
        Match($hostId : systemId, $productId : productId, $subscriptionId : subscriptionId, kind == Kind.CONFIRMED)
        Subscription(id == $subscriptionId, policy == Policy.UNLIMITED_VIRTUALIZATION)
        HostGuest(hostId == $hostId, $guestId : guestId)
        Match(systemId == $guestId, productId == $productId, subscriptionId == $subscriptionId, kind == Kind.POSSIBLE, quantity == 0.0)
    then
        insert(new Match($guestId, $productId, $subscriptionId, 0.0, Kind.CONFIRMED));
end
