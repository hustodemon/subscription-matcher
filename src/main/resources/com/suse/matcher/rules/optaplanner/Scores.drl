package com.suse.matcher.rules.optaplanner;

import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder;

import java.util.LinkedList;

import com.suse.matcher.facts.FreeMatch;
import com.suse.matcher.facts.HostGuest;
import com.suse.matcher.facts.Penalty;
import com.suse.matcher.facts.PinnedMatch;
import com.suse.matcher.facts.Subscription;
import com.suse.matcher.facts.System;
import com.suse.matcher.facts.SystemProduct;
import com.suse.matcher.solver.Match;

global HardSoftScoreHolder scoreHolder;


// Hard constraints: no solution can ever be produced if any of those is broken
// (that is, score is less than 0). If that happens, we found a bug!

// Note that the construction heuristic must be able to construct a solution
// with score 0, so that the final solution can never be unacceptable

rule "calculate12Penalties"
  when
    // a 1-2 subscription is used for VMs on a certain host
    Subscription($subscriptionId : id, policy == Policy.ONE_TWO) and
    Match($systemId : systemId, subscriptionId == $subscriptionId, confirmed == true) and
    HostGuest($hostId : hostId, guestId == $systemId)
    accumulate (
        // count the number of VMs that use that subscription on the host
        Match($guestId : systemId, subscriptionId == $subscriptionId, confirmed == true) and
        HostGuest(hostId == $hostId, guestId == $guestId);
        $count : count();
        // if the number of VMs is odd...
        ($count % 2) == 1
    )
  then
    // ...add a 50 cent penalty. This ensures a whole number of subscriptions is
    // always used for the same host
    insertLogical(new Penalty($subscriptionId, 50));
end

rule "dontExceedSubscriptionCount"
    when
        Subscription($subscriptionId: id, $quantity : quantity, ignored == false)
        accumulate (
            Match($cents : cents, subscriptionId == $subscriptionId, confirmed == true);
            $usedCents : sum($cents)
        )
        accumulate (
            Penalty(subscriptionId == $subscriptionId, $cents: cents);
            $penaltyCents : sum($cents)
        )
    then
        int availableCents = $quantity * 100;
        int totalUsedCents = $usedCents.intValue() + $penaltyCents.intValue();
        scoreHolder.addHardConstraintMatch(kcontext,
            (availableCents - totalUsedCents) >= 0 ? 0 :
            // limit penalty to 10 points
            -10 + availableCents * 9 / totalUsedCents
        );
end

rule "dontMatchTwice"
    when
        Match($systemId : systemId, $productId : productId, $subscriptionId : subscriptionId, confirmed == true) and
        (
            Match(systemId == $systemId, productId == $productId, subscriptionId != $subscriptionId, confirmed == true) or
            (
                FreeMatch(systemId == $systemId, productId == $productId, $requiredMatchId : requiredMatchId) and
                Match(id == $requiredMatchId, confirmed == true)
            )
        )
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

// Soft constraints: we try to find the solution that maximizes the score, but there are no guarantees.

rule "maximizeCoveredInstallations"
    when
        SystemProduct($systemId : systemId, $productId : productId) and
        (
            Match(systemId == $systemId, productId == $productId, confirmed == true) or
            (
                FreeMatch(systemId == $systemId, productId == $productId, $requiredMatchId : requiredMatchId) and
                Match(id == $requiredMatchId, confirmed == true)
            )
        )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 10);
end

rule "maximizePinnedMatches"
    when
        PinnedMatch($systemId : systemId, $subscriptionId : subscriptionId)
        Match(systemId == $systemId, subscriptionId == $subscriptionId, confirmed == true) or
        (
            FreeMatch($requiredMatchId : requiredMatchId, systemId == $systemId, subscriptionId == $subscriptionId) and
            Match(id == $requiredMatchId, confirmed == true)
        )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1);
end
