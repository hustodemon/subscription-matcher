package com.suse.matcher.rules.optaplanner;

import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder;

import com.suse.matcher.facts.HostGuest;
import com.suse.matcher.facts.IncompatibleGroups;
import com.suse.matcher.facts.PartialMatch;
import com.suse.matcher.facts.Penalty;
import com.suse.matcher.facts.PinnedMatch;
import com.suse.matcher.facts.Subscription;
import com.suse.matcher.facts.System;
import com.suse.matcher.facts.SystemProduct;
import com.suse.matcher.solver.Match;

global HardSoftScoreHolder scoreHolder;

// Hard constraints: no solution can ever be produced if any of those is broken
// (that is, score is less than 0). If that happens, we found a bug!

// Note that the construction heuristic must be able to construct a solution
// with score 0, so that the final solution can never be unacceptable

rule "calculate12Penalties"
  when
    HostGuest($hostId : hostId)
    Subscription($subscriptionId : id, policy != null && policy == Policy.ONE_TWO, ignored == false)
    accumulate (
        // count the number of VMs that use a certain 1:2 subscription on one host
        HostGuest($guestId : guestId, hostId == $hostId) and
        PartialMatch($groupId : groupId, systemId == $guestId, subscriptionId == $subscriptionId) and
        Match(id == $groupId, confirmed == true);
        $count : count();
        // if it is odd...
        ($count % 2) == 1
    )
  then
    // ...add a 50 cent penalty. This ensures a whole number of subscriptions is
    // always used for the same host
    insertLogical(new Penalty($subscriptionId, $hostId, 50));
end

rule "dontExceedSubscriptionCount"
    when
        Subscription($subscriptionId: id, $quantity : quantity, ignored == false)
        accumulate (
            PartialMatch($cents : cents, $groupId : groupId, subscriptionId == $subscriptionId) and
            Match(id == $groupId, confirmed == true);
            $usedCents : sum($cents)
        )
        accumulate (
            Penalty(subscriptionId == $subscriptionId, $cents: cents);
            $penaltyCents : sum($cents)
        )
    then
        int availableCents = $quantity * 100;
        int totalUsedCents = $usedCents.intValue() + $penaltyCents.intValue();
        scoreHolder.addHardConstraintMatch(kcontext,
            (availableCents - totalUsedCents) >= 0 ? 0 :
            // limit penalty to 10 points
            -10 + availableCents * 9 / totalUsedCents
        );
end


// Soft constraints: we try to find the solution that maximizes the score, but there are no guarantees.

rule "maximizeCoveredInstallations"
    when
        SystemProduct($systemId : systemId, $productId : productId)
        PartialMatch($groupId : groupId, systemId == $systemId, productId == $productId)
        Match(id == $groupId, confirmed == true)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 10);
end

rule "maximizePinnedMatches"
    when
        PinnedMatch($systemId : systemId, $subscriptionId : subscriptionId)
        PartialMatch($groupId : groupId, systemId == $systemId, subscriptionId == $subscriptionId)
        Match(id == $groupId, confirmed == true)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1);
end
