package com.suse.matcher.rules;

import com.suse.matcher.facts.Match;
import com.suse.matcher.facts.Match.Kind;
import com.suse.matcher.facts.Subscription;
import com.suse.matcher.facts.SubscriptionProduct;
import com.suse.matcher.facts.System;
import com.suse.matcher.facts.SystemProduct;

rule "match valid user-specified matches"
    agenda-group "Matching"
    salience 2
    when
        Match($systemId : systemId, $subscriptionId : subscriptionId, $productId : productId, $quantity: quantity, kind == Kind.USER_PINNED)
        Match(systemId == $systemId, subscriptionId == $subscriptionId, productId == $productId, quantity == $quantity, kind == Kind.POSSIBLE)
    then
        insert(new Match($systemId, $subscriptionId, $productId, 1, Kind.CONFIRMED));
end

rule "match non-stackable matches"
    agenda-group "Matching"
    salience $subscription.computeFitnessTo($system) // result in interval [0, 1]
    when
        $system : System($systemId : id)
        $subscription : Subscription(
            $subscriptionId : id,
            $systemLimit : systemLimit,
            systemLimit > 0,
            stackable == false
        )

        SystemProduct($productId : productId, systemId == $systemId)
        SubscriptionProduct(subscriptionId == $subscriptionId, productId == $productId)

        Match(systemId == $systemId, subscriptionId == $subscriptionId, kind == Kind.POSSIBLE)
        not (Match(systemId == $systemId, kind == Kind.CONFIRMED))
    then
        insert(new Match($systemId, $subscriptionId, $productId, 1, Kind.CONFIRMED));
        modify($subscription) {
            systemLimit = $systemLimit -1
        }
end

rule "match stackable matches"
    // NOTE: the only stackable subscriptions are TWO_TWO
    // and UNLIMITED_VIRTUAL after 2015, only on physical hosts
    agenda-group "Matching"
    salience $subscription.computeFitnessTo($system) // result in interval [0, 1]
    when
        $system : System($systemId : id, physical)
        $subscription : Subscription(
            $subscriptionId : id,
            $systemLimit : systemLimit,
            $startsAt : startsAt,
            $expiresAt : expiresAt,
            $sccOrgId : sccOrgId,
            $policy : policy,
            $supportLevel : supportLevel,
            systemLimit > 0,
            stackable == true
        )

        SystemProduct($productId : productId, systemId == $systemId)
        SubscriptionProduct(subscriptionId == $subscriptionId, productId == $productId)

        Match(systemId == $systemId, subscriptionId == $subscriptionId, kind == Kind.POSSIBLE)

        // require that other CONFIRMED subscriptions on this system and product are all
        // stackable, from the same SCC Org Id, support level, dates, policy
        forall (
            $otherMatch : Match(systemId == $systemId, productId == $productId, kind == Kind.CONFIRMED)
            Subscription(
                id == $otherMatch.subscriptionId,
                startsAt == $startsAt,
                expiresAt == $expiresAt,
                sccOrgId == $sccOrgId,
                policy == $policy,
                supportLevel == $supportLevel,
                stackable == true
            )
        )

        // require that there are still some unlicensed cpus
        accumulate (
            Match(systemId == $systemId, subscriptionId == $subscriptionId, $quantity : quantity, kind == Kind.CONFIRMED);
            $alreadyLicensedCpus : sum($quantity * $subscription.cpus)
        )
        System(id == $systemId, $alreadyLicensedCpus < $system.cpus)
    then
        Integer quantity = $subscription.computeQuantityFor($system, $alreadyLicensedCpus);
        insert(new Match($systemId, $subscriptionId, $productId, quantity, Kind.CONFIRMED));
        modify($subscription) {
            systemLimit = $systemLimit - quantity
        }
end
